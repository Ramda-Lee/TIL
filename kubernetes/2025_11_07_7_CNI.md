# 쿠버네티스

## Prerequisite Container Network Interface

### CNI가 필요한 이유
컨테이너 런타임(Docker, rkt, Mesos 등)은 모두 네임스페이스·브리지·veth 등을 조합해 비슷한 네트워크 구성을 만든다. 같은 문제를 매번 구현하지 않도록 표준을 만들자는 아이디어에서 Container Network Interface(CNI)가 탄생했다. CNI는 “네트워크 플러그인을 어떻게 호출하고 어떤 책임을 져야 하는가”를 정의한 규격이다.

### 기본 개념
- **플러그인**: 실제 네트워크 작업을 수행하는 실행 파일(예: `bridge`, `macvlan`, `flannel`, `calico` 등).
- **컨테이너 런타임**: 플러그인을 호출하는 주체(Kubernetes, rkt, CRI-O 등).
- **CNI 스펙**: 플러그인과 런타임이 지켜야 할 호출 방식·입출력 포맷·책임 범위를 명시한다.

### 런타임의 책임
1. 컨테이너마다 네트워크 네임스페이스를 생성한다.
2. 컨테이너가 연결해야 할 네트워크를 파악한다.
3. 컨테이너 생성 시 플러그인을 `ADD` 명령으로 호출하고, 삭제 시 `DEL`로 호출한다.
4. 플러그인 설정(JSON)과 환경 변수를 올바르게 전달한다.

### 플러그인의 책임
- `ADD`, `DEL`, `CHECK` 명령을 지원하고 컨테이너 ID, 네임스페이스 경로, 인터페이스 이름 등의 인수를 처리한다.
- 인터페이스 생성, IP 할당, 라우팅/NAT 설정 등 실제 네트워크 구성을 수행한다.
- 결과를 CNI 규격에 맞는 JSON으로 반환한다.

### 구성 파일 예시
런타임은 `/etc/cni/net.d/10-bridge.conf`와 같은 JSON 파일로 플러그인을 설정한다.
```json
{
  "cniVersion": "1.1.0",
  "name": "mynet",
  "type": "bridge",
  "bridge": "cni0",
  "isDefaultGateway": true,
  "ipMasq": true,
  "ipam": {
    "type": "host-local",
    "subnet": "10.244.0.0/16"
  }
}
```
런타임은 컨테이너를 생성한 뒤 위 설정을 사용해 `bridge` 플러그인과 `host-local` IPAM을 호출한다.

### IP 주소 관리(IPAM)
- CNI 스펙은 **Pod IP 할당 책임**을 플러그인(또는 별도 IPAM 모듈)에 맡긴다.
- `ipam` 섹션에서 어떤 IPAM을 쓸지 정의한다.
  - `host-local`: 각 노드 로컬 디렉터리에 IP 풀 파일을 만들어 관리한다. 기본 CNI 패키지에 포함되어 있으며 중복 방지를 위해 사용/반환을 추적한다.
  - `dhcp`: 외부 DHCP 서버에 요청해 IP를 할당받는다.
  - 서드파티 플러그인(예: Infoblox, Calico IPAM 등)도 동일 규격을 따른다.
- IPAM 모듈은 서브넷/게이트웨이/라우트 정보도 함께 제공해 Pod 네임스페이스에 설정할 수 있도록 한다.

### 플러그인 생태계
CNI는 기본으로 `bridge`, `ipvlan`, `macvlan`, `host-local`, `dhcp` 등을 제공하고, 서드파티 플러그인(Flannel, Calico, Weave, Cilium, VMware NSX, Infoblox 등)도 모두 동일한 규격을 따른다. 덕분에 어떤 런타임이든 원하는 플러그인을 조합할 수 있다.

### Docker와 CNI
도커 엔진 자체는 CNI 대신 CNM(Container Network Model)을 사용한다. 따라서 Docker CLI에서 직접 CNI 플러그인을 지정할 수는 없지만, Kubernetes처럼 “컨테이너를 네트워크 없이 생성한 뒤 CNI 플러그인을 별도로 실행”하는 방식으로 연동이 가능하다.
