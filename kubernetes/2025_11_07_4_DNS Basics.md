# 쿠버네티스

## DNS Basics

### DNS 입문 강의 개요
DNS를 처음 접하는 사람을 위해 리눅스 호스트에서의 DNS 개념과 주요 명령어를 살펴본다. 같은 네트워크에 있는 두 호스트 A(192.168.1.1)와 B(192.168.1.11)가 있다고 가정하고, IP 대신 기억하기 쉬운 이름(DB)으로 통신하려면 무엇이 필요한지부터 출발한다.

### /etc/hosts 를 이용한 이름 해석
호스트 A는 기본적으로 이름 DB를 알지 못하므로 `ping db`는 실패한다. A의 `/etc/hosts` 파일에 `192.168.1.11 db`와 같이 IP와 이름을 매핑하면 A는 DB라는 이름을 해당 IP로 해석한다. `/etc/hosts`에 적힌 내용은 A 입장에서 진실로 간주되므로 실제 호스트명이 host2라 해도 A는 이를 알지 못한다. 심지어 `google.com`을 시스템 B의 IP에 매핑하면 A에게는 B가 Google처럼 보인다. 즉 `/etc/hosts`는 로컬에서의 이름-주소 해석(name resolution)을 담당한다.

### DNS 서버가 필요한 이유와 resolv.conf
소규모 환경에서는 각 시스템의 `/etc/hosts`로 충분하지만 시스템 수가 늘어나고 IP가 자주 바뀌면 유지보수가 어렵다. 그래서 모든 매핑을 중앙 DNS 서버(예: 192.168.1.100)로 옮기고 각 호스트의 `/etc/resolv.conf` 파일에 `nameserver 192.168.1.100`과 같이 DNS 서버를 지정한다. 이렇게 하면 호스트가 모르는 이름을 만날 때 DNS 서버에 질의해 최신 IP를 얻을 수 있다. 특정 테스트 서버처럼 개인만 쓰는 대상은 여전히 로컬 `/etc/hosts`에 추가할 수 있으며, 그 경우 해당 호스트에서만 이름이 해석된다.

### hosts와 DNS 조회 순서 (nsswitch.conf)
동일한 이름이 `/etc/hosts`와 DNS 서버 모두에 존재하면 조회 순서에 따라 결과가 달라진다. `/etc/nsswitch.conf` 파일의 `hosts:` 줄에서 순서를 정의하며 기본값은 `files dns`라 로컬 파일을 먼저 본다. 필요하면 순서를 바꿔 DNS를 우선하도록 조정할 수 있다.

### 퍼블릭 DNS, 도메인 구조, 캐시
로컬 DNS에 없는 외부 도메인(예: `facebook.com`)을 조회하려면 `resolv.conf`에 8.8.8.8 같은 공용 네임서버를 추가하거나, 내부 DNS 서버가 모르는 도메인을 공용 DNS로 포워딩하도록 설정한다. 도메인 이름은 점으로 구분된 계층 구조(루트 → 최상위 도메인 → 도메인 → 서브도메인)를 따른다. 예: `www.google.com`에서 `.`은 루트, `com`은 TLD, `google`은 도메인, `www`는 서브도메인이다. 여러 DNS 서버를 순차적으로 거치며 최종 IP를 찾고, 이후 질의를 빠르게 하기 위해 DNS 서버가 결과를 짧은 기간 캐싱할 수 있다.

### 조직 내부 도메인과 search 도메인
회사 도메인이 `mycompany.com`이고 내부 웹 서버가 `web.mycompany.com`이라면 외부 사용자는 전체 도메인으로 접근하지만 내부 직원은 단순히 `web`만 입력하고 싶을 수 있다. `/etc/resolv.conf`에 `search mycompany.com product.mycompany.com`처럼 검색 도메인을 지정하면 호스트가 `web`을 입력했을 때 `web.mycompany.com`, `web.product.mycompany.com` 순으로 자동 시도한다. 질의에 이미 도메인이 포함되어 있으면 search 도메인을 덧붙이지 않는다.

### DNS 레코드 유형과 진단 도구
DNS 서버에는 다양한 레코드가 저장된다.
- A 레코드: IPv4 주소 ↔ 호스트 이름
- AAAA 레코드: IPv6 주소 ↔ 호스트 이름 (쿼드 A)
- CNAME 레코드: 한 이름을 다른 이름에 매핑(별칭)

DNS 문제를 점검할 때 `ping`만으로는 부족할 수 있다. `nslookup`은 지정한 DNS 서버에 질의하지만 로컬 `/etc/hosts`를 참고하지 않으므로, 로컬에만 있는 이름은 찾지 못한다. `dig`는 더 상세한 응답을 제공하며, DNS 서버에 저장된 레코드 형태와 유사한 정보를 확인할 수 있다. 이어지는 실습에서는 실제 리눅스 환경에서 DNS를 구성하고 트러블슈팅하는 과정을 다룬다.

### CoreDNS로 DNS 서버 구성하기
이전 강의에서 DNS 서버가 필요한 이유와 각 호스트에서 `resolv.conf`로 DNS를 지정하는 방법을 살펴봤다면, 이번에는 실제로 한 대의 리눅스 호스트를 CoreDNS 기반 DNS 서버로 구성해 본다. CoreDNS는 바이너리와 Docker 이미지 모두 제공하지만 여기서는 바이너리를 직접 내려받아 사용한다.

```bash
curl -LO https://github.com/coredns/coredns/releases/download/v1.12.4/coredns_1.12.4_linux_amd64.tgz
tar -zxf coredns_1.12.4_linux_amd64.tgz
./coredns
```

기본적으로 53번 포트에서 대기한다. 아직 IP-호스트 매핑을 주지 않았으므로 `/etc/hosts`에 필요한 레코드를 넣고, CoreDNS가 해당 파일을 읽도록 Corefile을 작성한다.

```txt
.:53 {
    hosts /etc/hosts {
        reload 1m
        fallthrough
    }

    forward . /etc/resolv.conf {
       max_concurrent 1000
    }
    cache 30
    log
    errors
}
```

이 설정은 `/etc/hosts`에 기록된 매핑을 DNS 응답으로 내보내고, 일치하지 않는 질의는 서버의 `/etc/resolv.conf`에 정의된 상위 DNS로 전달한다. `reload` 옵션 덕분에 `hosts` 파일이 변경되면 주기적으로 다시 읽으며 `cache` 는 단기 캐시를 제공한다. CoreDNS는 hosts 플러그인 외에도 다양한 플러그인을 제공하며, 쿠버네티스 환경에서는 별도의 플러그인이 사용된다. 더 자세한 내용은 CoreDNS 공식 문서를 참고한다.