# 쿠버네티스

## Vertical Pod Autoscaling

### 수동(Vertical) 스케일링 방법
- kubectl top pod 명령으로 리소스 사용량 모니터링 (Metrics Server 필요)
- 임계치 도달하면 kubectl edit deployment 실행
- Pod 템플릿 내 container 섹션에서 CPU/Memory request와 limit 수정
- 저장하면 기존 pod 종료되고, 새 리소스로 정의된 pod가 생성됨

### Vertical Pod Autoscaler 개요
- 기능:
  - HPA처럼 자동화된 방식으로 리소스를 관리
  - Pod의 CPU/Memory 사용량을 모니터링 후 자동으로 자원 증감
  - Pod당 리소스 최적화에 집중
- 차이점:
  - HPA(Horizontal Pod Autoscaler)는 Pod 개수를 늘림
  - VPA는 Pod 크기(CPU/Memory)를 늘림
- 설치 필요:
  - HPA와 달리 기본 내장 아님
  - Github의 VPA 배포 파일을 클러스터에 직접 적용해야 함

### VPA 구성 요소
| 컴포넌트 | 역할 |
|--------|-----|
| Recommender | Pod의 실시간/과거 리소스 사용량을 수집해 최적의 CPU/Memory 값을 추천. 직접 수정하지 않고 권고만 제공 |
| Updater | Recommender의 정보를 받아, 리소스가 비효율적인 Pod를 감지 후 필요 시 Pod를 종료(evict) |
| Admission Controller | Pod 생성 시 개입, Recommender의 추천값을 Pod spec에 반영하여, 새 Pod가 올바른 리소스로 시작되도록 함 |
- 동작 흐름
  - Recommender -> 리소스 추천
  - Updater -> 조건에 맞으면 Pod 종료
  - Admission Controller -> 새 Pod가 생성될 때 권장 리소스로 시작하도록 수정

### VPA yaml 파일 예시
```
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: my-app-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: Deployment
    name: my-app
  resourcePolicy:
    containerPolicies:
    - containerName: my-app
      minAllowed:
        cpu: "200m"
      maxAllowed:
        cpu: "2"
  updatePolicy:
    updateMode: "Auto"
```

### VPA 업데이트 모드
| 모드 | 동작 방식 |
| off | 추천만 제공. Pod에는 적용되지 않음 (Recommender만 동작) |
| Initial | Pod 생성 시점에만 추천 적용. (Admission Controller 개입, Updater는 미사용) |
| Recreate | Updater가 동작. 임계치 초과 Pod를 종료 후 새 Pod 생성 |
| Auto | 현재는 Recreate와 동일. 향후 in-place 업데이트 기능이 안정화되면 Pod 종료 없이 적용 예정 |

### VPA vs HPA 비교
| 구분 | VPA (Vertical Pod Autoscaler) | HPA (Horizontal Pod Autoscaler) |
|------|-------------------------------|---------------------------------|
| 스케일 방식 | Pod 리소스 크기(CPU/Memory) 조정 | Pod 개수 증감 |
| Pod 동작 방식 | Pod를 재시작하여 새로운 리소스 값 적용 → 다운타임 발생 가능 | 기존 Pod 유지, 새 Pod 추가 → 무중단 운영 |
| 트래픽 급증 대응 | 대응 속도 느림 (Pod 재시작 필요) | 빠르게 대응 (Pod 즉시 추가 가능) |
| 비용 최적화 | Pod별 리소스를 실제 사용량에 맞게 조정 → 과다 할당 방지 | 필요 없는 Pod를 줄여 효율화 → 자원 낭비 방지 |
| 적합한 워크로드 | - Stateful 앱<br>- CPU/Memory 집약적 앱<br>- DB, JVM 기반 앱, AI/ML | - Stateless 앱<br>- 웹 서버, API 서버, 메시지 큐 등<br>- 급격한 트래픽 변동에 강함 |
| 설치 여부 | 기본 내장 아님 → 별도 배포 필요 | Kubernetes에 기본 내장 |
| 주요 목적 | Pod 하나의 성능 최적화 | 전체 Pod 수로 부하 분산 |

### 사용 시나리오
- VPA 권장:
	-	Stateful 워크로드
	-	CPU/Memory 튜닝이 중요한 DB, JVM, AI/ML
	-	초기에는 높은 자원 필요하지만 이후 감소하는 앱
- HPA 권장:
	- Stateless 워크로드
	-	웹 애플리케이션, API 서버, 마이크로서비스
	-	빠른 트래픽 변동 대응 필요