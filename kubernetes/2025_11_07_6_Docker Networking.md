# 쿠버네티스

## Docker Networking

### Docker 네트워크 모드 개요
Docker 컨테이너는 네트워크를 여러 방식으로 사용할 수 있다.
- `none`: 어떤 네트워크에도 연결되지 않아 외부와 통신할 수 없다.
- `host`: 컨테이너가 호스트의 네트워크 스택을 그대로 공유한다. 포트 충돌에 주의해야 한다.
- `bridge`: Docker가 호스트 내부에 구축하는 기본 사설 네트워크(기본 CIDR 172.17.0.0/16)로, 컨테이너마다 독립 IP를 부여받는다.

### 기본 bridge 네트워크 구조
Docker를 설치하면 `docker0`라는 브리지 인터페이스가 자동 생성된다 (`docker network ls`에서 이름은 `bridge`). `ip link`에서 확인할 수 있고, 기본 IP는 `172.17.0.1`. 컨테이너가 생성될 때마다 Docker는 새 네트워크 네임스페이스를 만들고 veth 페어를 생성해 한쪽을 컨테이너에, 다른 쪽을 `docker0`에 붙인다. 컨테이너 내부에서 `ip addr`을 보면 172.17.0.x 주소가 할당된 인터페이스가 보인다.

### 컨테이너 간 통신
동일한 브리지 네트워크에 속한 컨테이너들은 172.17.0.0/16 대역에서 서로 ping/통신이 가능하다. 호스트에서도 해당 대역을 통해 접근할 수 있지만, 호스트 밖에서는 이 네트워크를 직접 볼 수 없다.

### 포트 매핑으로 외부 노출
사설 네트워크 안 컨테이너의 서비스를 외부에 노출하려면 `-p 8080:80`처럼 포트 매핑을 설정한다. 그러면 호스트의 8080으로 들어온 트래픽이 컨테이너의 80번 포트로 전달된다. Docker는 내부적으로 iptables NAT 규칙(PREROUTING)에 DNAT 룰을 추가해 목적지 IP/포트를 컨테이너로 바꾼다. `iptables -t nat -S`로 보면 Docker가 추가한 규칙을 확인할 수 있다.

### none / host 모드와의 비교
- `none`: 완전 격리 상태로 테스트용 컨테이너를 빠르게 만들 때 유용하지만, 실제 서비스에선 별도 네트워크 구성이 필요하다.
- `host`: 네트워크 네임스페이스를 사용하지 않아 성능은 좋지만, 보안 격리와 포트 충돌 문제로 다중 컨테이너 배포에는 적합하지 않다.

### 네임스페이스와 Docker
앞선 네트워크 네임스페이스 강의와 동일한 방식으로 Docker도 컨테이너마다 네임스페이스를 생성한다. `docker inspect <container>`에서 `SandboxID`를 확인하면 대응되는 네임스페이스 이름을 찾을 수 있으며, `ip netns exec`로 내부 인터페이스/라우팅/ARP 테이블을 확인할 수 있다.

컨테이너 네트워킹은 결국 네임스페이스, veth, 브리지, iptables 조합으로 구현된다. 다음 강의에서는 이러한 구성을 표준화한 CNI(Container Network Interface)를 살펴본다.
