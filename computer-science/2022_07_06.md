# 운영체제 #2

## 프로세스 스케줄링
- 배치 처리 시스템 : 프로그램들을 순차적으로 실행한다.
- 시분할 시스템 : 여러명이 컴퓨터를 동시에 사용하면 어떨지 -> 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템
- 멀티 태스킹 : 단일 CPU에서 응용프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
- 멀티 프로그래밍 : 최대한 CPU를 많이 활용하도록 하는 시스템
- 멀티 프로세싱 : 여러 CPU에서 하나의 응용 프로그램을 병렬로 실행하여 실행 속도를 높이는 기법

## 스케줄링 알고리즘
- 프로세스 실행 순서
1. 목표 수립 
2. 목표 달성 평가 기준 수립
3. 알고리즘 개발
4. 평가 기준에 따른 성능 평가

## 스케줄링 성능 평가 기준
- CPU Utilization (이용률 %) : 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율
- Throughput(처리율, jobs/sec) :  CPU가 단위 시간당 처리하는 프로세스의 개수
- 소요 시간 (Turnaround Time) : 프로세스가 시작해서 끝날 때까지 걸리는 시간
- 대기 시간 (Wationg Time) : 프로세스가 준비 큐 내에서 대기하는 시간의 총합
- 응답 시간(Response Time) : 대화식 시스템에서 요청 후 응답이 오기 시작할 때까지의 시간

## FIFO 스케줄러
- 배치처리 시스템을 이용한 스케줄러
- 수행시간이 긴 프로세스의 경우, 나머지 프로세스의 Waiting Time 증가
- Convoy Effect : 하나의 수행시간이 긴 프로세스로 인해 나머지 프로세가 오래 기다면서 CPU의 효율성이 낮아지는 현상

## SLF 스케줄러 (최단 작업 우선 스케줄러)
- Convoy Effect를 해결하기 위해 고려할 수 있는 스케줄러
- 가장 프로세스 실행 시간이 짧은 프로세스로 부터 먼저 실행 시키는 알고리즘
- 주어진 프로세스에 대해 최소의 평균 대기 시간을 보장
- 수행시간이 긴 프로세스는 뒤로 물러나는 기아 현상이 발생할 수 있다

## Round Robin 스케줄러
- 기아 현상을 해결하기 위해 나온 스케줄러
- 작은 단위의 시간인 시간 할당량을 정의하여 그 시간 만큼 자원을 할당하는 방식
- 하드웨어적 타이머가 필요하다.

## 우선순위 기반 스케줄러
- 프로세스마다 우선순위라는 속성이 붙는다, 우선순위 스케줄링도 선점, 비선점형으로 스케줄링이 가능하다.
- 숫자가 높을 수록 우선 순위가 높고 만약 우선순위가 같다면 FIFO 방식으로 동작한다.

## 프로세스 상태 기반 스케줄러
- running state : 현재 CPU에서 실행 상태
- ready state : CPU에서 실행 가능 상태 (실행 대기 상태)
- block state : 특정 이벤트 발생 대기 상태

## 프로세스 구조
- text : CODE
- data : 변수/초기화 데이터
- stack : 임시데이터 (함수 호출, 로컬 변수)
- heap : 코드에서 동적으로 만들어지는 데이터  
(JAVA GC와 프로세스 힙 : 불필요한 객체가 차지하는 힙 공간을 삭제하여, 힙 공간 확보가 필요함)
## 프로세스와 컴퓨터 구조
- PC(Program Counter) + SP (Stack Pointer)
- PC : 다음 실행할 코드 주소
- SP : 스택 최상단 주소

## 컨텍스트 스위칭
- CPU에 실행할 프로세스를 교체하는 기술
- PC, SP만 바꿔주면 프로세스 저장 상태를 기반으로 싱핼 가능
