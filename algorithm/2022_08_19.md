# 코딩테스트 - 다이나믹 프로그래밍 #2

## 피보나치 수열의 효율적인 해법 : 다이나믹 프로그래밍
- 다이나믹 프로그래밍의 사용 조건을 만족하는지 확인한다
    - 최적 부분 구조
    - 중복되는 부분 문제

## 탑다운 vs 바텀업
- 탑다운(메모이제이션)방식은 하향식이라고 하며, 바텀업은 상향식이라 한다
- 다이나믹 프로그래밍의 전형적인 형태는 바텀업 형태
    - 결과 저장요 리스트는 DP 테이블이라 한다
- 메모이제이선 : 한 번 계산한 결과를 메모리 공간에 메모하는 기법
    - 값을 기록하는 의미로 캐싱이라고 한다

## 피보나치 수열 : 다이나믹 프로그래밍 해결
```
탑다운 방식

# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현 ( 탑다운 다이나믹 프로그래밍 )
def fibo(x):
  # 종료 조건 (1 or 2 일 때 1을 반환)
  if x == 1 or x == 2:
    return 1
  # 이미 계산한 문제면 그 결과 반환
  if d[x] != 0:
    return d[x]
  # 아직 계산하지 않은 문제는 점화식에 따라 피보나치 결과 반환
  d[x] = fibo( x - 1) + fibo( x -2 )
  return d[x]

print(fibo(99))

# 결과
218922995834555169026

----------------------------------------------------------
바텀업 방식

# 앞서 계산된 결과를 저장하기 위해 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현
for i in range(2, n+1):
  d[i] = d[i-1] + d[i-2]
  
print(d[n])

# 결과
218922995834555169026

```

## 다이나믹 프로그래밍 vs 분할 정복
- 다이나믹 프로그래밍과 분항 정복은 모두 최적 부분 구조를 가질 때 사용할 수 있다
- 다이나믹 프로그래밍과 분할 정복의 차이점은 부분 문제의 중복
    - 분할 정복 문제는 동일한 부분 문제가 반복적으로 계산되지 않는다

## 다이나믹 프로그래밍 문제에 접근하는 방법
- 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요
- 먼저 그리디, 구현, 완전 탐색으로 문제 해결할 수 있는 지 검토 -> 방법이 없으면 다이나믹 프로그래밍
 - 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤(탑다운) 작은 문제에서 구한 값이 큰 문제에서 사용될 수 있으면, 코드를 개선하는 방식
 - 일반적인 코딩테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제가 많이 된다

