# 코딩테스트 - 재귀함수

## 재귀 함수
- 자기 자신을 다시 호출하는 함수
- 재귀적으로 동작한다 or Recursive적으로 동작한다는 재귀함수 사용

## 재귀 함수의 종료 조건
- 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야한다
- 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있다
- 재귀함수는 내부적으로 스택 자료구조와 동일하다
- 예제
```
def recursive_function(i):
  # 100번째 호출 했을 때 종료되도록 조건 명시
  if i == 100:
    return
  print(i, '번째 재귀함수에서', i + 1, '번째 재귀함수를 호출합니다.')
  recursive_function(i + 1)
  print(i, '번째 재귀함수를 종료합니다.')

recursive_function(1)

```
## 반복문과 재귀문의 차이
- 반복문에 비해 재귀문의 함수가 더욱 간결하다
- 간결한 이유는 재귀함수가 수학의 점화식을 그대로 소스코드로 옮겼기 때문이다
- 반복문과 재귀문의 차이 예제 -1 : 팩토리얼 예제
```
# 반복적으로 구현한 n!
def factorial_iterative(n):
   result = 1
   # 1부터 n까지의 수를 차례대로 곱하기
   for i in range(1, n+1):
       result *= i
   return result

#재귀적으로 구현한 n!
def factorial_recursive(n):
   if n <= 1: #n이 1이하인 경우  1 반환
     return 1
   # n! = n * (n-1)!를 그대로 코드로 작성하기
   return n * factorial_recursive(n-1)

# 각 방식으로 구현한 n! 출력 (n =3)
print('반복적으로 구현:', factorial_iterative(6))
print('재귀적으로 구현:', factorial_recursive(6))

# 결과
반복적으로 구현: 720
재귀적으로 구현: 720

```

- 반복문과 재귀문의 차이 예제 -2 : 최대공약수(유클리드 호제법) 계산 예제
- 두 개의 자연수에 대한 최대공약수를 구하는 대표적인 알고리즘으로는 유클리드 호제법이 있다
- 유클리드 호제법
    - 두 자연수 A, B에 대하야 (A>B) A를 B로 나눈 나머지를 R이 라고 할 때,  
      A와 B의 최대공약수는 B와 R의 최대공약수와 같다
- 유클리드 호제법 아이디어 그대로 재귀함수로 작성할 수 있다
```
def gcd(a, b):
  if a % b == 0:
    return b
  else:
    return gcd(b, a%b)

print(gcd(192, 162))

# 결과
6
```

## 재귀함수 사용 시 유의사항
- 재귀함수를 활용하면 복잡한 알고리즘을 간단히 해결할 수 있지만, 다른 사람이 이해하기 어려운 코드가 될 수 있어 신중하게 사용한다
- 모든 재귀함수는 반복문을 이용하여 동일한 기능을 구현할 수 있다
- 재귀 함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있다
- 컴퓨터가 함수를 연속으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓여, 스택 사용 시 구현상 스택 라이브러리 보다 재귀함수를 이용하는 경우가 많다
